# 선택 정렬(Selection Sort) 설명

## 기본 개념
선택 정렬은 배열에서 가장 작은 원소를 찾아 맨 앞으로 이동시키는 과정을 반복하는 정렬 알고리즘입니다.

## 시각적 예시
배열 [64, 25, 12, 22, 11]을 정렬해봅시다:

### 초기 상태
```
[ 64 | 25 | 12 | 22 | 11 ]
  ↑    
현재위치
```

### 1단계: 전체 배열에서 최솟값(11) 찾기
```
[ 64 | 25 | 12 | 22 | 11 ]
  ↑                   ↑
현재위치           최솟값
```

### 1단계: 교환
```
[ 11 | 25 | 12 | 22 | 64 ]
  ↑    ↑
정렬됨  현재위치
```

### 2단계: 남은 배열에서 최솟값(12) 찾기
```
[ 11 | 25 | 12 | 22 | 64 ]
  ↑    ↑    ↑
정렬됨 현재  최솟값
```

### 2단계: 교환
```
[ 11 | 12 | 25 | 22 | 64 ]
  ↑    ↑    ↑
정렬됨 정렬됨 현재위치
```

### 3단계: 남은 배열에서 최솟값(22) 찾기
```
[ 11 | 12 | 25 | 22 | 64 ]
  ↑    ↑    ↑    ↑
정렬됨 정렬됨 현재  최솟값
```

### 3단계: 교환
```
[ 11 | 12 | 22 | 25 | 64 ]
  ↑    ↑    ↑    ↑
정렬됨 정렬됨 정렬됨 현재위치
```

### 4단계: 남은 배열에서 최솟값(25) 찾기 - 이미 올바른 위치
```
[ 11 | 12 | 22 | 25 | 64 ]
  ↑    ↑    ↑    ↑    ↑
정렬됨 정렬됨 정렬됨 정렬됨 정렬됨
```

## 시간 복잡도: O(n²)
매 단계마다 최솟값을 찾기 위해 n번, n-1번, n-2번... 비교를 수행하므로 n(n-1)/2 ≈ n²

## 의사 코드
```
selectionSort(array)
    n = 배열의 길이
    
    for i = 0 to n-1
        // 최솟값의 인덱스 찾기
        min_index = i
        for j = i+1 to n-1
            if array[j] < array[min_index]
                min_index = j
            end if
        end for
        
        // 최솟값과 현재 위치 교환
        if min_index != i
            swap array[i] and array[min_index]
        end if
    end for
end selectionSort
```

## 특징
- **장점**: 구현이 단순하고 교환 횟수가 적음
- **단점**: 항상 O(n²) 시간이 소요되어 대용량 데이터에 비효율적